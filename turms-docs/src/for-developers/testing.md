# 测试

## 关于压力测试

### 为什么Turms服务端不提供压测报告

对于两个做了相同功能的Java简单函数，我们可以通过JMH轻松地测试它们各自的性能表现。但对于Turms这种稍大的项目而言，不存在这样的银弹。其复杂性主要体现在这么三个方面：

1. Turms支持多种不同的架构，很多功能也都支持开闭。举例来说，我们在[配置参数](https://turms-im.github.io/docs/for-developers/config.html#%E9%87%8D%E8%A6%81%E6%80%A7)篇章有提到了一些用例甚至不需要做数据存储，那在其他条件相同的情况下，不做存储的应用自然吞吐量比要做存储的快。

   又比如我们在[关于消息的可达性、有序性与重复性](https://turms-im.github.io/docs/for-developers/status-aware.html#%E5%85%B3%E4%BA%8E%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E4%B8%8E%E9%87%8D%E5%A4%8D%E6%80%A7)提到，Turms服务端默认关闭对100%消息必达的支持的，原因是支持100%消息必达是有代价的，它需要至少一个Redis服务端做会话级别的序列号分发工作，每发一条消息都需要请求一个序列号，其吞吐量自然是不如不支持100%消息必达的场景。

   又比如我们在[可观察测性体系-日志](https://turms-im.github.io/docs/for-developers/observability.html#%E6%97%A5%E5%BF%97)篇章有讲到Turms服务端默认并推荐对用户请求进行100%采样，而100%采样需要大量的I/O操作，其吞吐量自然比不过完全不进行采样的操作。

2. Turms提供很多缓存功能，且未来将支持更多缓存功能。缓存是空间换时间的经典例子。以群组成员缓存为例，群组成员发送消息时，Turms服务端需要查询该群组的成员列表。那对于使用了缓存的场景，Turms服务端可以基于本地Map做查询，其吞吐量自然远高于不使用缓存而向数据库发送查询请求的场景，但不使用缓存的场景优势就在于群组列表的实时性高。

2. 单机与分布式的压测结果也完全不一样。甚至Turms服务端还将支持：在单机部署场景，Turms服务端支持Unix Domain Socket，而无需走TCP连接。

综上，如果Turms只想写个好看的压测报告，Turms服务端可以不做任何数据存储、不保证消息必达、不对日志做任何采样，对所有数据都进行长时间的缓存，其最终的吞吐量自然很高，但这样的压测报告就如同空中楼阁，没有多少真实场景会使用这么一套配置。这也是我们做中大型软件开发的人不太愿意直接提供简单压测报告的原因。

另外，不仅是Turms，其实对于任何技术方案来说，我们在看它或快或慢的时候，主要是为了探究“它什么这么快/慢？”。举例来说，我们在研究JVM为什么会占这么多内存时，如果我们只看到了Java极为冗余与普遍的对象头时，我们会感叹“原来是冗余设计问题，难怪占这么多内存”，但如果我们又看了JVM对Code Cache的设计与使用，我们又会感叹“原来是空间换时间，难怪占这么多内存”，评价方向截然不同。归根到底就是外行看热闹，内行看门道。Turms为了方便用户看其中的门道，因此文档都写得比较详尽，方便用户自行评测Turms适不适用于自己的应用场景。

尽管Turms没计划提供压测报告，但我们后期会写一套基于Kotlin的DSL帮助用户编写压测脚本，甚至是像nGrinder那样一套更为复杂的分布式压测平台。